{% extends "base.html" %}

{% block content %}
<section class="search-container">
    <div class="search-input-group">
        <input type="search" id="search-bar" class="search-input" placeholder="Search anime titles..."
            aria-label="Search anime" autocomplete="off">
        <div class="loading-indicator" id="loading" hidden></div>
    </div>

    <div id="status-message" class="status-message" aria-live="polite"></div>

    <div id="anime-results" class="anime-grid" role="list"></div>
</section>

<script>
    // Debounce function to limit rapid API calls
    const debounce = (func, delay = 300) => {
        let timeoutId;
        return (...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
    };

    // DOM elements
    const searchBar = document.getElementById('search-bar');
    const resultsContainer = document.getElementById('anime-results');
    const statusMessage = document.getElementById('status-message');
    const loadingIndicator = document.getElementById('loading');

    // API configuration
    const API = {
        search: '/search_anime',
        details: '/anime_details'
    };

    // Controller for aborting pending fetch requests
    let abortController = new AbortController();

    const handleSearch = debounce(async (query) => {
        try {
            // Abort previous request
            abortController.abort();
            abortController = new AbortController();

            // Clear previous results
            resultsContainer.innerHTML = '';
            statusMessage.textContent = '';

            if (!query.trim()) {
                statusMessage.textContent = '';
                return;
            }

            loadingIndicator.hidden = false;
            statusMessage.textContent = 'Searching...';

            // Fetch anime IDs
            const searchResponse = await fetch(`${API.search}?q=${encodeURIComponent(query)}`, {
                signal: abortController.signal
            });

            if (!searchResponse.ok) throw new Error('Search request failed');
            const animeIds = await searchResponse.json();

            console.log(animeIds)

            if (!animeIds.length) {
                statusMessage.textContent = 'Nothing found';
                return;
            }

            const fetchAnimeDetails = async (animeIds) => {
                statusMessage.textContent = '';
                try {
                    for (let animeId of animeIds) {
                        const response = await fetch(`/anime_details/${animeId}`);

                        const anime = await response.json();
                        const animeCard = document.createElement('a');
                        console.log(anime)
                        animeCard.href = `/anime/${anime._id.$oid}`;
                        animeCard.classList.add('anime-card');
                        animeCard.innerHTML = `
                            <img src="${anime.image_url}" alt="${anime.title}">
                            <h3>${anime.title}</h3>
                            <p>${anime.description}</p>
                        `;
                        resultsContainer.appendChild(animeCard);
                    }
                    console.log('All fetch requests completed.');
                } catch (error) {
                    console.error('Error fetching anime details:', error);
                }
            };

            fetchAnimeDetails(animeIds)


        } catch (error) {
            if (error.name !== 'AbortError') {
                console.error('Search error:', error);
                statusMessage.textContent = 'Error performing search';
            }
        } finally {
            loadingIndicator.hidden = true;
        }
    }, 300);

    function renderResults(animeList) {
        const fragment = document.createDocumentFragment();

        animeList.forEach(anime => {
            if(anime._id){
                const card = document.createElement('a');
                card.href = `/anime/${anime._id.$oid}`;
                card.className = 'anime-card';
                card.innerHTML = `
                    <div class="anime-card__content">
                        <h3 class="anime-card__title">${anime.title}</h3>
                        <p class="anime-card__description">${truncate(anime.description, 100)}</p>
                    </div>
                `;
                fragment.appendChild(card);
            }
        });

        resultsContainer.appendChild(fragment);
    }

    // Utility function to truncate text
    function truncate(text, maxLength) {
        return text.length > maxLength ?
            text.substring(0, maxLength) + '...' : text;
    }

    // Event listeners
    searchBar.addEventListener('input', (e) => {
        handleSearch(e.target.value.trim());
    });

    // Initial cleanup
    resultsContainer.innerHTML = '';
    statusMessage.textContent = '';
</script>
{% endblock %}